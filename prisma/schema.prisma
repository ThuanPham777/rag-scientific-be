// ============================================================================
// RAG SCIENTIFIC - DATABASE SCHEMA
//
// This is the canonical, production-ready schema for the entire system.
// Database: PostgreSQL with Prisma
//
// ARCHITECTURE:
// - Single PostgreSQL database shared by both services
// - Backend (rag-scientific-be) owns: users, papers, conversations, etc.
// - RAG service (RAG_BE_02) owns: rag_paper_cache, paper_content_summaries
// - Coordination via `rag_file_id` UUID
//
// DESIGN PRINCIPLES:
// - Single source of truth: `papers` table owns ALL paper metadata
// - No data duplication between services
// - RAG tables are minimal (cache only, no metadata duplication)
//
// TABLE NAMING: snake_case for all tables and columns
// ============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// RAG SERVICE TABLES (documented here, managed by this schema)
// ============================================================================
//
// Table: rag_paper_cache
// Purpose: Minimal RAG processing cache (file hash for rebuild detection)
// Owner: RAG_BE_02
// Note: Does NOT store metadata - that's in `papers` table
//
// Columns:
// - rag_paper_id VARCHAR(100) PRIMARY KEY  -- Links to papers.rag_file_id
// - file_content_hash VARCHAR(64)          -- Hash for rebuild detection
// - last_processed_at TIMESTAMPTZ          -- When last processed
// - created_at TIMESTAMPTZ
//
// Table: paper_content_summaries
// Purpose: Cache LLM-generated summaries for tables and images
// Owner: RAG_BE_02
//
// Columns:
// - id SERIAL PRIMARY KEY
// - rag_paper_id VARCHAR(100)              -- Links to rag_paper_cache
// - content_type VARCHAR(20)               -- 'table' or 'image'
// - content_index INTEGER                  -- Position in extraction order
// - content_hash VARCHAR(64)               -- Hash for cache invalidation
// - summary_text TEXT                      -- The LLM-generated summary
// - created_at TIMESTAMPTZ
// ============================================================================

// ============================================================================
// SECTION 1: USER MANAGEMENT
// ============================================================================

enum AuthProvider {
  LOCAL   // Email/password registration
  GOOGLE  // Google OAuth
}

/// User account - supports both local and OAuth authentication
model User {
  id            String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email         String       @unique @db.VarChar(255)

  // === Local Auth (nullable for OAuth users) ===
  passwordHash  String?      @map("password_hash") @db.VarChar(255)

  // === OAuth Support ===
  provider      AuthProvider @default(LOCAL)
  providerId    String?      @map("provider_id") @db.VarChar(255)

  // === Profile ===
  displayName   String?      @map("display_name") @db.VarChar(100)
  avatarUrl     String?      @map("avatar_url") @db.VarChar(500)

  // === Status ===
  isActive      Boolean      @default(true) @map("is_active")
  lastLoginAt   DateTime?    @map("last_login_at") @db.Timestamptz

  // === Timestamps ===
  createdAt     DateTime     @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime     @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  papers            Paper[]
  conversations     Conversation[]
  refreshTokens     RefreshToken[]
  folders           Folder[]
  highlights        Highlight[]
  highlightComments HighlightComment[]

  @@unique([provider, providerId])
  @@index([email])
  @@map("users")
}

// ============================================================================
// SECTION 2: REFRESH TOKENS
// ============================================================================

/// Refresh token for JWT authentication
model RefreshToken {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @map("user_id") @db.Uuid

  token       String   @unique @db.VarChar(500)
  deviceInfo  String?  @map("device_info") @db.VarChar(500)
  ipAddress   String?  @map("ip_address") @db.VarChar(50)

  expiresAt   DateTime @map("expires_at") @db.Timestamptz
  isRevoked   Boolean  @default(false) @map("is_revoked")

  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

// ============================================================================
// SECTION 3: FOLDER MANAGEMENT
// ============================================================================

/// Folder - organize papers in user's library
model Folder {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @map("user_id") @db.Uuid

  name        String   @db.VarChar(100)
  orderIndex  Int      @default(0) @map("order_index")

  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  papers      Paper[]

  @@unique([userId, name])
  @@index([userId])
  @@index([orderIndex])
  @@map("folders")
}

// ============================================================================
// SECTION 4: PAPERS (SINGLE SOURCE OF TRUTH)
//
// This is THE authoritative table for all paper data.
// - Backend owns this table
// - RAG service reads from this table when it needs paper metadata
// - NO duplication of metadata in RAG tables
// ============================================================================

/// Paper/PDF document - SINGLE SOURCE OF TRUTH for all paper data
model Paper {
  id              String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId          String      @map("user_id") @db.Uuid
  folderId        String?     @map("folder_id") @db.Uuid

  // === File Storage (Cloud) - SINGLE SOURCE FOR URL ===
  fileName        String      @map("file_name") @db.VarChar(255)
  fileUrl         String      @map("file_url") @db.VarChar(1000)  // S3 URL
  fileSize        BigInt?     @map("file_size")
  fileHash        String?     @map("file_hash") @db.VarChar(64)   // For deduplication

  // === RAG Service Integration ===
  ragFileId       String      @unique @map("rag_file_id") @db.VarChar(100)

  // === Metadata (extracted by RAG, stored here as source of truth) ===
  title           String?     @db.VarChar(500)
  abstract        String?     @db.Text
  authors         String?     @db.Text  // JSON array string
  numPages        Int?        @map("num_pages")

  // === Processing Status ===
  status          PaperStatus @default(PENDING)
  errorMessage    String?     @map("error_message") @db.Text

  // === Ingestion Statistics ===
  nodeCount       Int?        @map("node_count")
  tableCount      Int?        @map("table_count")
  imageCount      Int?        @map("image_count")

  // === Timestamps ===
  processedAt     DateTime?   @map("processed_at") @db.Timestamptz
  createdAt       DateTime    @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime    @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user               User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  folder             Folder?             @relation(fields: [folderId], references: [id], onDelete: SetNull)
  conversations      Conversation[]
  conversationPapers ConversationPaper[]
  suggestedQuestions SuggestedQuestion[]
  relatedPapers      RelatedPaper[]
  highlights         Highlight[]

  @@index([userId])
  @@index([folderId])
  @@index([ragFileId])
  @@index([status])
  @@map("papers")
}

enum PaperStatus {
  PENDING     // Uploaded, waiting for RAG
  PROCESSING  // RAG is processing
  COMPLETED   // RAG finished successfully
  FAILED      // RAG failed
}

// ============================================================================
// SECTION 5: CONVERSATIONS & MESSAGES
// ============================================================================

enum ConversationType {
  SINGLE_PAPER
  MULTI_PAPER
}

/// Conversation - chat session with papers
model Conversation {
  id            String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId        String           @map("user_id") @db.Uuid
  paperId       String           @map("paper_id") @db.Uuid

  title         String?          @db.VarChar(300)
  type          ConversationType @default(SINGLE_PAPER)

  createdAt     DateTime         @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime         @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user               User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  paper              Paper               @relation(fields: [paperId], references: [id], onDelete: Cascade)
  messages           Message[]
  conversationPapers ConversationPaper[]

  @@index([userId])
  @@index([paperId])
  @@index([createdAt])
  @@index([type])
  @@map("conversations")
}

/// ConversationPaper - Join table for multi-paper conversations
model ConversationPaper {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId  String   @map("conversation_id") @db.Uuid
  paperId         String   @map("paper_id") @db.Uuid
  orderIndex      Int      @default(0) @map("order_index")

  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  paper           Paper        @relation(fields: [paperId], references: [id], onDelete: Cascade)

  @@unique([conversationId, paperId])
  @@index([conversationId])
  @@index([paperId])
  @@map("conversation_papers")
}

enum MessageRole {
  USER
  ASSISTANT
}

/// Message - individual chat message
model Message {
  id              String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId  String      @map("conversation_id") @db.Uuid

  role            MessageRole
  content         String      @db.Text

  // For USER messages with image
  imageUrl        String?     @map("image_url") @db.VarChar(1000)

  // For ASSISTANT messages - RAG metadata
  modelName       String?     @map("model_name") @db.VarChar(100)
  tokenCount      Int?        @map("token_count")
  context         Json?       @default("{}") @db.JsonB

  createdAt       DateTime    @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([createdAt])
  @@map("messages")
}

// ============================================================================
// SECTION 6: SUGGESTED QUESTIONS
// ============================================================================

/// Cached suggested questions for a paper
model SuggestedQuestion {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  paperId       String   @map("paper_id") @db.Uuid

  question      String   @db.Text
  orderIndex    Int      @map("order_index")

  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  paper         Paper    @relation(fields: [paperId], references: [id], onDelete: Cascade)

  @@index([paperId])
  @@map("suggested_questions")
}

// ============================================================================
// SECTION 7: RELATED PAPERS
// ============================================================================

/// Cached related paper from arXiv
model RelatedPaper {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  paperId       String   @map("paper_id") @db.Uuid

  arxivId       String   @map("arxiv_id") @db.VarChar(50)
  title         String   @db.VarChar(500)
  abstract      String   @db.Text
  authors       String[] @db.VarChar(255)
  categories    String[] @db.VarChar(50)
  url           String   @db.VarChar(500)

  score         Float
  reason        String   @db.Text

  orderIndex    Int      @map("order_index")
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  paper         Paper    @relation(fields: [paperId], references: [id], onDelete: Cascade)

  @@unique([paperId, arxivId])
  @@index([paperId])
  @@map("related_papers")
}

// ============================================================================
// SECTION 8: HIGHLIGHTS & ANNOTATIONS
// ============================================================================

/// Highlight color options for text selections
enum HighlightColor {
  YELLOW
  GREEN
  BLUE
  PINK
  ORANGE
}

/// Highlight - text selection annotation on a PDF page
model Highlight {
  id              String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  paperId         String          @map("paper_id") @db.Uuid
  userId          String          @map("user_id") @db.Uuid

  // === Page Location ===
  pageNumber      Int             @map("page_number")

  // === Selection Metadata (for re-rendering) ===
  // Stores PDF.js text layer selection data
  // Format: [{ x: number, y: number, width: number, height: number }]
  selectionRects  Json            @map("selection_rects") @db.JsonB

  // Text content of the highlight (for search/display)
  selectedText    String          @map("selected_text") @db.Text

  // === Optional text anchor for fallback re-rendering ===
  textPrefix      String?         @map("text_prefix") @db.VarChar(100)
  textSuffix      String?         @map("text_suffix") @db.VarChar(100)

  // === Styling ===
  color           HighlightColor  @default(YELLOW)

  // === Timestamps ===
  createdAt       DateTime        @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime        @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  paper           Paper           @relation(fields: [paperId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments        HighlightComment[]

  @@index([paperId])
  @@index([userId])
  @@index([paperId, pageNumber])
  @@map("highlights")
}

/// Comment on a highlight
model HighlightComment {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  highlightId     String    @map("highlight_id") @db.Uuid
  userId          String    @map("user_id") @db.Uuid

  content         String    @db.Text

  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  highlight       Highlight @relation(fields: [highlightId], references: [id], onDelete: Cascade)
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([highlightId])
  @@index([userId])
  @@map("highlight_comments")
}

