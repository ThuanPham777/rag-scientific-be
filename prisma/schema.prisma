// ============================================================================
// RAG SCIENTIFIC - DATABASE SCHEMA
//
// This is the canonical, production-ready schema for the entire system.
// Database: PostgreSQL with Prisma
//
// ARCHITECTURE:
// - Single PostgreSQL database shared by both services
// - Backend (rag-scientific-be) owns: users, papers, conversations, etc.
// - RAG service (RAG_BE_02) owns: rag_paper_cache, paper_content_summaries
// - Coordination via `rag_file_id` UUID
//
// DESIGN PRINCIPLES:
// - Single source of truth: `papers` table owns ALL paper metadata
// - No data duplication between services
// - RAG tables are minimal (cache only, no metadata duplication)
// - No folder management â€” papers are flat, organized by conversations
//
// TABLE NAMING: snake_case for all tables and columns
// ============================================================================

generator client {
  provider     = "prisma-client"
  output       = "../generated/prisma"
  moduleFormat = "cjs"
}

datasource db {
  provider = "postgresql"
}


// ============================================================================
// RAG SERVICE TABLES (documented here, managed by this schema)
// ============================================================================
//
// Table: rag_paper_cache
// Purpose: Minimal RAG processing cache (file hash for rebuild detection)
// Owner: RAG_BE_02
// Note: Does NOT store metadata - that's in `papers` table
//
// Table: paper_content_summaries
// Purpose: Cache LLM-generated summaries for tables and images
// Owner: RAG_BE_02
// ============================================================================

/// RAG processing cache - managed by RAG service (RAG_BE_02)
model RagPaperCache {
  ragPaperId       String    @id @map("rag_paper_id") @db.VarChar(100)
  fileContentHash  String?   @map("file_content_hash") @db.VarChar(64)
  lastProcessedAt  DateTime? @map("last_processed_at") @db.Timestamptz
  createdAt        DateTime  @default(now()) @map("created_at") @db.Timestamptz

  @@map("rag_paper_cache")
}

/// Paper content summaries - managed by RAG service (RAG_BE_02)
model PaperContentSummary {
  id            Int      @id @default(autoincrement())
  ragPaperId    String   @map("rag_paper_id") @db.VarChar(100)
  contentType   String   @map("content_type") @db.VarChar(20)
  contentIndex  Int      @map("content_index")
  contentHash   String   @map("content_hash") @db.VarChar(64)
  summaryText   String   @map("summary_text") @db.Text
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@unique([ragPaperId, contentType, contentIndex])
  @@index([ragPaperId])
  @@index([ragPaperId, contentType])
  @@map("paper_content_summaries")
}

// ============================================================================
// SECTION 1: USER MANAGEMENT
// ============================================================================

enum AuthProvider {
  LOCAL   // Email/password registration
  GOOGLE  // Google OAuth
}

/// User account - supports both local and OAuth authentication
model User {
  id            String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email         String       @unique @db.VarChar(255)

  // === Local Auth (nullable for OAuth users) ===
  passwordHash  String?      @map("password_hash") @db.VarChar(255)

  // === OAuth Support ===
  provider      AuthProvider @default(LOCAL)
  providerId    String?      @map("provider_id") @db.VarChar(255)

  // === Profile ===
  displayName   String?      @map("display_name") @db.VarChar(100)
  avatarUrl     String?      @map("avatar_url") @db.VarChar(500)

  // === Password Reset ===
  passwordResetToken     String?   @map("password_reset_token") @db.VarChar(255)
  passwordResetExpiresAt DateTime? @map("password_reset_expires_at") @db.Timestamptz

  // === Status ===
  isActive      Boolean      @default(true) @map("is_active")
  lastLoginAt   DateTime?    @map("last_login_at") @db.Timestamptz

  // === Timestamps ===
  createdAt     DateTime     @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime     @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  papers            Paper[]
  folders           Folder[]
  conversations     Conversation[]
  refreshTokens     RefreshToken[]
  highlights        Highlight[]
  highlightComments HighlightComment[]
  sessionMembers    SessionMember[]
  sessionInvites    SessionInvite[]
  messages          Message[]
  messageReactions  MessageReaction[]

  @@unique([provider, providerId])
  @@index([email])
  @@map("users")
}

// ============================================================================
// SECTION 2: REFRESH TOKENS
// ============================================================================

/// Refresh token for JWT authentication
model RefreshToken {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @map("user_id") @db.Uuid

  token       String   @unique @db.VarChar(500)
  deviceInfo  String?  @map("device_info") @db.VarChar(500)
  ipAddress   String?  @map("ip_address") @db.VarChar(50)

  expiresAt   DateTime @map("expires_at") @db.Timestamptz
  isRevoked   Boolean  @default(false) @map("is_revoked")

  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

// ============================================================================
// SECTION 3: FOLDER MANAGEMENT
// ============================================================================

/// Folder - organize papers in user's library
model Folder {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @map("user_id") @db.Uuid

  name        String   @db.VarChar(100)
  orderIndex  Int      @default(0) @map("order_index")

  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  papers      Paper[]

  @@unique([userId, name])
  @@index([userId])
  @@index([orderIndex])
  @@map("folders")
}


// ============================================================================
// SECTION 3: PAPERS (SINGLE SOURCE OF TRUTH)
//
// This is THE authoritative table for all paper data.
// - Backend owns this table
// - RAG service reads from this table when it needs paper metadata
// - NO duplication of metadata in RAG tables
// - When a group chat is started, the paper is CLONED (new Paper row + new ragFileId)
// ============================================================================

/// Paper/PDF document - SINGLE SOURCE OF TRUTH for all paper data
model Paper {
  id              String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId          String      @map("user_id") @db.Uuid

  folderId        String?     @map("folder_id") @db.Uuid

  // === File Storage (Cloud) - SINGLE SOURCE FOR URL ===
  fileName        String      @map("file_name") @db.VarChar(255)
  fileUrl         String      @map("file_url") @db.VarChar(1000)  // S3 URL
  fileSize        BigInt?     @map("file_size")
  fileHash        String?     @map("file_hash") @db.VarChar(64)   // For deduplication

  // === RAG Service Integration ===
  ragFileId       String      @unique @map("rag_file_id") @db.VarChar(100)

  // === Metadata (extracted by RAG, stored here as source of truth) ===
  title           String?     @db.VarChar(500)
  abstract        String?     @db.Text
  authors         String?     @db.Text  // JSON array string
  summary         String?     @db.Text  // LLM-generated paper summary
  numPages        Int?        @map("num_pages")

  // === Processing Status ===
  status          PaperStatus @default(PENDING)
  errorMessage    String?     @map("error_message") @db.Text

  // === Ingestion Statistics ===
  nodeCount       Int?        @map("node_count")
  tableCount      Int?        @map("table_count")
  imageCount      Int?        @map("image_count")

  // === Timestamps ===
  processedAt     DateTime?   @map("processed_at") @db.Timestamptz
  createdAt       DateTime    @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime    @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user               User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  folder             Folder?             @relation(fields: [folderId], references: [id], onDelete: SetNull)
  conversations      Conversation[]
  relatedPapers      RelatedPaper[]
  highlights         Highlight[]

  @@index([userId])
  @@index([folderId])
  @@index([ragFileId])
  @@index([status])
  @@map("papers")
}

enum PaperStatus {
  PENDING     // Uploaded, waiting for RAG
  PROCESSING  // RAG is processing
  COMPLETED   // RAG finished successfully
  FAILED      // RAG failed
}

// ============================================================================
// SECTION 4: CONVERSATIONS & MESSAGES
// ============================================================================

enum ConversationType {
  SINGLE_PAPER
  MULTI_PAPER
  GROUP
}

/// Conversation - chat session with papers
model Conversation {
  id            String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId        String           @map("user_id") @db.Uuid
  paperId       String?          @map("paper_id") @db.Uuid

  title         String?          @db.VarChar(300)
  type          ConversationType @default(SINGLE_PAPER)

  // === Collaborative Session ===
  isCollaborative Boolean        @default(false) @map("is_collaborative")
  sessionCode    String?         @unique @map("session_code") @db.VarChar(20)
  maxMembers     Int             @default(10) @map("max_members")

  createdAt     DateTime         @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime         @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user               User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  paper              Paper?              @relation(fields: [paperId], references: [id], onDelete: Cascade)
  messages           Message[]
  suggestedQuestions SuggestedQuestion[]
  sessionMembers     SessionMember[]
  sessionInvites     SessionInvite[]

  @@index([userId])
  @@index([paperId])
  @@index([createdAt])
  @@index([type])
  @@index([isCollaborative])
  @@map("conversations")
}

enum MessageRole {
  USER
  ASSISTANT
  SYSTEM
}

/// Message - individual chat message
model Message {
  id              String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId  String      @map("conversation_id") @db.Uuid
  userId          String?     @map("user_id") @db.Uuid

  role            MessageRole
  content         String      @db.Text

  // For USER messages with image
  imageUrl        String?     @map("image_url") @db.VarChar(1000)

  // For ASSISTANT messages - RAG metadata
  modelName       String?     @map("model_name") @db.VarChar(100)
  tokenCount      Int?        @map("token_count")
  context         Json?       @default("{}") @db.JsonB

  // === Reply-to-message (thread-style) ===
  replyToMessageId String?    @map("reply_to_message_id") @db.Uuid

  // === Soft delete ===
  deletedAt       DateTime?   @map("deleted_at") @db.Timestamptz

  createdAt       DateTime    @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  conversation    Conversation     @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user            User?            @relation(fields: [userId], references: [id], onDelete: SetNull)
  replyToMessage  Message?         @relation("MessageReplies", fields: [replyToMessageId], references: [id], onDelete: SetNull)
  replies         Message[]        @relation("MessageReplies")
  reactions       MessageReaction[]

  @@index([conversationId])
  @@index([createdAt])
  @@index([userId])
  @@index([replyToMessageId])
  @@map("messages")
}

// ============================================================================
// SECTION 5: MESSAGE REACTIONS
// ============================================================================

/// Reaction on a message
model MessageReaction {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  messageId   String   @map("message_id") @db.Uuid
  userId      String   @map("user_id") @db.Uuid
  emoji       String   @db.VarChar(20)
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  message     Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([messageId])
  @@map("message_reactions")
}

// ============================================================================
// SECTION 6: SUGGESTED QUESTIONS
// ============================================================================

/// Cached suggested questions for a conversation
model SuggestedQuestion {
  id               String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId   String       @map("conversation_id") @db.Uuid

  question         String       @db.Text

  createdAt        DateTime     @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  conversation     Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("suggested_questions")
}

// ============================================================================
// SECTION 7: RELATED PAPERS
// ============================================================================

/// Cached related paper from arXiv
model RelatedPaper {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  paperId       String   @map("paper_id") @db.Uuid

  arxivId       String   @map("arxiv_id") @db.VarChar(50)
  title         String   @db.VarChar(500)
  abstract      String   @db.Text
  authors       String[] @db.VarChar(255)
  categories    String[] @db.VarChar(50)
  url           String   @db.VarChar(500)

  score         Float
  reason        String   @db.Text

  orderIndex    Int      @map("order_index")
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  paper         Paper    @relation(fields: [paperId], references: [id], onDelete: Cascade)

  @@unique([paperId, arxivId])
  @@index([paperId])
  @@map("related_papers")
}

// ============================================================================
// SECTION 8: HIGHLIGHTS & ANNOTATIONS
// ============================================================================

/// Highlight color options for text selections
enum HighlightColor {
  YELLOW
  GREEN
  BLUE
  PINK
  ORANGE
}

enum SessionRole {
  OWNER
  MEMBER
}

/// Highlight - text selection annotation on a PDF page
model Highlight {
  id              String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  paperId         String          @map("paper_id") @db.Uuid
  userId          String          @map("user_id") @db.Uuid

  // === Page Location ===
  pageNumber      Int             @map("page_number")

  // === Selection Metadata (for re-rendering) ===
  // Stores PDF.js text layer selection data
  // Format: [{ x: number, y: number, width: number, height: number }]
  selectionRects  Json            @map("selection_rects") @db.JsonB

  // Text content of the highlight (for search/display)
  selectedText    String          @map("selected_text") @db.Text

  // === Optional text anchor for fallback re-rendering ===
  textPrefix      String?         @map("text_prefix") @db.VarChar(100)
  textSuffix      String?         @map("text_suffix") @db.VarChar(100)

  // === Styling ===
  color           HighlightColor  @default(YELLOW)

  // === Timestamps ===
  createdAt       DateTime        @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime        @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  paper           Paper           @relation(fields: [paperId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments        HighlightComment[]

  @@index([paperId])
  @@index([userId])
  @@index([paperId, pageNumber])
  @@map("highlights")
}

/// Comment on a highlight
model HighlightComment {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  highlightId     String    @map("highlight_id") @db.Uuid
  userId          String    @map("user_id") @db.Uuid

  content         String    @db.Text

  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  highlight       Highlight @relation(fields: [highlightId], references: [id], onDelete: Cascade)
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([highlightId])
  @@index([userId])
  @@map("highlight_comments")
}

// ============================================================================
// SECTION 9: COLLABORATIVE SESSION MANAGEMENT
// ============================================================================

/// Session member - links users to collaborative conversations
model SessionMember {
  id              String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId  String      @map("conversation_id") @db.Uuid
  userId          String      @map("user_id") @db.Uuid

  role            SessionRole @default(MEMBER)
  isActive        Boolean     @default(true) @map("is_active")

  joinedAt        DateTime    @default(now()) @map("joined_at") @db.Timestamptz
  leftAt          DateTime?   @map("left_at") @db.Timestamptz

  // Relations
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([userId])
  @@map("session_members")
}

/// Session invite - shareable invite link for collaborative sessions
model SessionInvite {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId  String   @map("conversation_id") @db.Uuid
  invitedBy       String   @map("invited_by") @db.Uuid

  inviteToken     String   @unique @map("invite_token") @db.VarChar(100)
  expiresAt       DateTime @map("expires_at") @db.Timestamptz
  maxUses         Int      @default(0) @map("max_uses")  // 0 = unlimited
  useCount        Int      @default(0) @map("use_count")
  isRevoked       Boolean  @default(false) @map("is_revoked")

  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  inviter         User         @relation(fields: [invitedBy], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([inviteToken])
  @@index([expiresAt])
  @@map("session_invites")
}


