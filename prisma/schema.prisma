// ============================================================================
// SIMPLIFIED DATABASE SCHEMA FOR RAG SCIENTIFIC
// Designed to work directly with RAG_BE_02
// Database: PostgreSQL with Prisma
// ============================================================================

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// SECTION 1: USER MANAGEMENT (with OAuth Support)
// ============================================================================

enum AuthProvider {
  LOCAL   // Email/password registration
  GOOGLE  // Google OAuth
}

/// User account - supports both local and OAuth authentication
model User {
  id            String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  email         String       @unique @db.VarChar(255)

  // === Local Auth (nullable for OAuth users) ===
  passwordHash  String?      @map("password_hash") @db.VarChar(255)

  // === OAuth Support ===
  provider      AuthProvider @default(LOCAL)
  providerId    String?      @map("provider_id") @db.VarChar(255)  // Google sub/id

  // === Profile ===
  displayName   String?      @map("display_name") @db.VarChar(100)
  avatarUrl     String?      @map("avatar_url") @db.VarChar(500)

  // === Status ===
  isActive      Boolean      @default(true) @map("is_active")
  lastLoginAt   DateTime?    @map("last_login_at") @db.Timestamptz

  // === Timestamps ===
  createdAt     DateTime     @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime     @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  papers        Paper[]
  conversations Conversation[]
  refreshTokens RefreshToken[]
  folders       Folder[]

  @@unique([provider, providerId]) // Ensure unique OAuth accounts
  @@index([email])
  @@map("users")
}

// ============================================================================
// SECTION 1.5: REFRESH TOKEN (JWT Auth)
// ============================================================================

/// Refresh token for JWT authentication
model RefreshToken {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @map("user_id") @db.Uuid

  token       String   @unique @db.VarChar(500)              // Hashed refresh token
  deviceInfo  String?  @map("device_info") @db.VarChar(500)  // Browser/device info
  ipAddress   String?  @map("ip_address") @db.VarChar(50)    // IP address

  expiresAt   DateTime @map("expires_at") @db.Timestamptz    // Token expiration
  isRevoked   Boolean  @default(false) @map("is_revoked")    // Manual revoke

  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

// ============================================================================
// SECTION 2: FOLDER MANAGEMENT (My Library)
// ============================================================================

/// Folder - organize papers in user's library
model Folder {
  id          String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId      String   @map("user_id") @db.Uuid

  name        String   @db.VarChar(100)                         // Folder name

  // === Ordering ===
  orderIndex  Int      @default(0) @map("order_index")          // For custom ordering

  // === Timestamps ===
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  papers      Paper[]

  @@unique([userId, name])  // Unique folder name per user
  @@index([userId])
  @@index([orderIndex])
  @@map("folders")
}

// ============================================================================
// SECTION 3: PAPER MANAGEMENT
// Maps directly to RAG_BE_02's file_id concept
// ============================================================================

/// Paper/PDF document - core entity linking to RAG service
model Paper {
  id              String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId          String      @map("user_id") @db.Uuid
  folderId        String?     @map("folder_id") @db.Uuid              // Optional folder

  // === File Storage (Cloud) ===
  fileName        String      @map("file_name") @db.VarChar(255)      // Original filename
  fileUrl         String      @map("file_url") @db.VarChar(1000)      // S3/Cloud URL
  fileSize        BigInt?     @map("file_size")                        // File size in bytes
  fileHash        String?     @map("file_hash") @db.VarChar(64)       // MD5 hash for dedup

  // === RAG Service Integration ===
  // This is the key field - maps to file_id in RAG_BE_02
  ragFileId       String      @unique @map("rag_file_id") @db.VarChar(100)

  // === Metadata from RAG ingestion ===
  title           String?     @db.VarChar(500)                        // From GROBID
  abstract        String?     @db.Text                                // From GROBID
  authors         String?     @db.Text                                // JSON array string
  numPages        Int?        @map("num_pages")

  // === Processing Status ===
  // Maps to processing_status in RAG_BE_02
  status          PaperStatus @default(PENDING)
  errorMessage    String?     @map("error_message") @db.Text

  // === Ingestion Stats (from IngestionResult) ===
  nodeCount       Int?        @map("node_count")
  tableCount      Int?        @map("table_count")
  imageCount      Int?        @map("image_count")

  // === Timestamps ===
  processedAt     DateTime?   @map("processed_at") @db.Timestamptz   // When RAG finished
  createdAt       DateTime    @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime    @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  folder          Folder?     @relation(fields: [folderId], references: [id], onDelete: Cascade)
  conversations   Conversation[]
  conversationPapers ConversationPaper[]  // For multi-paper conversations
  suggestedQuestions SuggestedQuestion[]
  relatedPapers   RelatedPaper[]

  @@index([userId])
  @@index([folderId])
  @@index([ragFileId])
  @@index([status])
  @@map("papers")
}

enum PaperStatus {
  PENDING     // Uploaded, waiting for RAG
  PROCESSING  // RAG is processing
  COMPLETED   // RAG finished successfully
  FAILED      // RAG failed
}

// ============================================================================
// SECTION 3: CONVERSATION & CHAT HISTORY
// ============================================================================

/// Conversation type - distinguishes single-paper from multi-paper chats
enum ConversationType {
  SINGLE_PAPER  // Chat with one specific paper
  MULTI_PAPER   // Chat across multiple papers
}

/// Conversation - chat session with a paper
model Conversation {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId        String   @map("user_id") @db.Uuid
  paperId       String   @map("paper_id") @db.Uuid

  title         String?  @db.VarChar(300)                           // Auto-generated or user-set
  type          ConversationType @default(SINGLE_PAPER)             // Type of conversation

  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  paper         Paper    @relation(fields: [paperId], references: [id], onDelete: Cascade)
  messages      Message[]
  conversationPapers ConversationPaper[]  // For multi-paper conversations

  @@index([userId])
  @@index([paperId])
  @@index([createdAt])
  @@index([type])
  @@map("conversations")
}

/// ConversationPaper - Join table for multi-paper conversations
/// Stores which papers are included in a multi-paper conversation
model ConversationPaper {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId  String   @map("conversation_id") @db.Uuid
  paperId         String   @map("paper_id") @db.Uuid
  orderIndex      Int      @default(0) @map("order_index")          // Order of paper in conversation

  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  paper           Paper        @relation(fields: [paperId], references: [id], onDelete: Cascade)

  @@unique([conversationId, paperId])  // Each paper can only be added once per conversation
  @@index([conversationId])
  @@index([paperId])
  @@map("conversation_papers")
}

/// Message - individual chat message (user question or AI answer)
model Message {
  id              String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  conversationId  String      @map("conversation_id") @db.Uuid

  role            MessageRole                                       // USER or ASSISTANT
  content         String      @db.Text                              // Question or Answer

  // === For USER messages with image (explain region feature) ===
  imageUrl        String?     @map("image_url") @db.VarChar(1000)   // S3 URL of cropped region image

  // === For ASSISTANT messages - RAG response metadata ===
  modelName       String?     @map("model_name") @db.VarChar(100)   // Model used for generation
  tokenCount      Int?        @map("token_count")                    // Token count for response
  context         Json?       @default("{}") @db.JsonB              // Retrieved context from RAG (texts, tables, images)

  createdAt       DateTime    @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([createdAt])
  @@map("messages")
}

enum MessageRole {
  USER
  ASSISTANT
}

// ============================================================================
// SECTION 4: SUGGESTED QUESTIONS (Brainstorm feature)
// ============================================================================

/// Cached suggested questions for a paper
model SuggestedQuestion {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  paperId       String   @map("paper_id") @db.Uuid

  question      String   @db.Text
  orderIndex    Int      @map("order_index")

  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  paper         Paper    @relation(fields: [paperId], references: [id], onDelete: Cascade)

  @@index([paperId])
  @@map("suggested_questions")
}

// ============================================================================
// SECTION 5: RELATED PAPERS CACHE
// Cache results from RAG /related-papers endpoint
// ============================================================================

/// Cached related paper from arXiv (via RAG service)
model RelatedPaper {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  paperId       String   @map("paper_id") @db.Uuid          // Source paper

  // === arXiv Paper Info ===
  arxivId       String   @map("arxiv_id") @db.VarChar(50)
  title         String   @db.VarChar(500)
  abstract      String   @db.Text
  authors       String[] @db.VarChar(255)                    // Array of author names
  categories    String[] @db.VarChar(50)                     // arXiv categories
  url           String   @db.VarChar(500)

  // === Relevance ===
  score         Float                                        // Similarity score (0-1)
  reason        String   @db.Text                            // Why it's relevant

  // === Cache Control ===
  orderIndex    Int      @map("order_index")                 // Display order
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  paper         Paper    @relation(fields: [paperId], references: [id], onDelete: Cascade)

  @@unique([paperId, arxivId])  // One entry per related paper per source
  @@index([paperId])
  @@map("related_papers")
}
